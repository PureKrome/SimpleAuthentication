using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Reflection;
using System.Threading.Tasks;
using SimpleAuthentication.Core.Config;
using SimpleAuthentication.Core.Exceptions;
using SimpleAuthentication.Core.Providers;
using SimpleAuthentication.Core.Tracing;

namespace SimpleAuthentication.Core
{
    public class WebApplicationService
    {
        private readonly IAuthenticationProviderFactory _authenticationProviderFactory;
        private readonly string _callbackRoute;
        private readonly TraceSource _traceSource;
        private readonly Lazy<IDictionary<string, MethodInfo>> _cachedMethodInfo =
            new Lazy<IDictionary<string, MethodInfo>>(() => new Dictionary<string, MethodInfo>());

        public WebApplicationService(IAuthenticationProviderFactory authenticationProviderFactory,
            TraceSource traceSource,
            string callbackRoute)
        {
            if (authenticationProviderFactory == null)
            {
                throw new ArgumentNullException("authenticationProviderFactory");
            }

            if (traceSource == null)
            {
                throw new ArgumentNullException("traceSource");
            }

            _authenticationProviderFactory = authenticationProviderFactory;
            _traceSource = traceSource;

            _callbackRoute = callbackRoute;
        }

        public RedirectToProviderResult RedirectToProvider(RedirectToProviderData redirectToProviderData)
        {
            if (redirectToProviderData == null)
            {
                throw new ArgumentNullException("redirectToProviderData");
            }

            // Grab the Provider.
            var provider = GetAuthenticationProvider(redirectToProviderData.ProviderKey);

            // Where do we return to, after we've authenticated?
            var callbackUri = GenerateCallbackUri(redirectToProviderData.RequestUrl, _callbackRoute);

            // Determine where we need to redirect to.
            var redirectToAuthenticateSettings = provider.GetRedirectToAuthenticateSettings(callbackUri);
            if (redirectToAuthenticateSettings == null)
            {
                // We failed to determine where to go. A classic example of this is with OpenId and a bad OpenId endpoint.
                const string errorMessage =
                    "No redirect to authencate settings retrieved. This means we don't know where to go. A classic example of this is with OpenId and a bad OpenId endpoint. Please check the data you are providing to the Controller. Otherwise, you will need to debug the individual provider class you are trying use to connect with.";
                _traceSource.TraceError(errorMessage);
                throw new AuthenticationException(errorMessage);
            }

            // Remember any important information for later, after we've returned back here.
            var cacheData = new CacheData(redirectToProviderData.ProviderKey,
                redirectToAuthenticateSettings.State,
                DetermineReturnUrl(redirectToProviderData.ReturnUrl,
                    redirectToProviderData.Referer));

            return new RedirectToProviderResult(redirectToAuthenticateSettings.RedirectUri,
                cacheData);
        }

        public async Task<TResult> AuthenticateCallbackAsync<TInvokeObject, TModuleOrController, TResult>(
            TInvokeObject objectToInvokeOn,
            TModuleOrController moduleOrController,
            AuthenticateCallbackAsyncData data)
        {
            if (data == null)
            {
                throw new ArgumentNullException("data");
            }

            _traceSource.TraceVerbose("Retrieving Cache values - State and RedirectToUrl.");

            _traceSource.TraceInformation("Previous CacheData: {0}",
                data.CacheData == null
                    ? "--no cache data"
                    : data.CacheData.ToString());

            // If we don't have some previous state value cached, then it's possible we're trying to just
            // hack into the callback directly. ie. CSRF.
            if (data.CacheData == null ||
                string.IsNullOrWhiteSpace(data.CacheData.State))
            {
                throw new AuthenticationException(
                    "No cache data or cached State value was found which generally means that a Cross Site Request Forgery attempt might be made. A 'State' value is generated by the server when a client prepares to redirect to an Authentication Provider and passes that generated state value to that Provider. The provider then passes that state value back, which proves that the client (ie. that's -you-) have actually authenticated against a provider. Otherwise, anyone can just hit the callback Url and impersonate another user, bypassing the authentication stage. So what's the solution: make sure you call the 'RedirectToProvider' endpoint *before* you hit the 'AuthenticateCallbackAsync' callback endpoint.");
            }

            var model = await RetrieveUserInformationAsync(data);

            // Do we have an optional redirect resource? Usually a previous referer?
            if (!string.IsNullOrWhiteSpace(data.CacheData.ReturnUrl))
            {
                _traceSource.TraceVerbose("Found return url: " + data.CacheData.ReturnUrl);
                model.ReturnUrl = data.CacheData.ReturnUrl;
            }

            // Finally! We can hand over the logic to the consumer to do whatever they want.
            _traceSource.TraceVerbose("About to execute your custom callback provider logic.");

            // NOTICE: We have to invoke an object instead of having strongly typed interfaces
            //         because the instace might be for a Nancy Module (with specific Nancy params)
            //         or an MVC Module (with that specific MVC params).
            // PERF QUESTION: Is it worth only caching the MethodInfo? Is it worth it?
            var result = GetCachedMethodInfo<TInvokeObject, TModuleOrController, TResult>(objectToInvokeOn, 
                moduleOrController, 
                model);

            return result;
        }

        public async Task<IAuthenticatedClient> AuthenticateMeAsync(string providerKey, AccessToken accessToken)
        {
            if (string.IsNullOrWhiteSpace(providerKey))
            {
                throw new ArgumentNullException("providerKey");
            }

            if (accessToken == null)
            {
                throw new ArgumentNullException("accessToken");
            }

            // Which provider did we just authenticate with?
            var provider = GetAuthenticationProvider(providerKey);

            // Grab the user information.
            return await provider.AuthenticateClientAsync(accessToken);
        }

        private IAuthenticationProvider GetAuthenticationProvider(string providerKey)
        {
            if (string.IsNullOrEmpty(providerKey))
            {
                throw new ArgumentNullException("providerKey");
            }

            _traceSource.TraceVerbose("Trying to retrieve a provider for the given key: " + providerKey);

            IAuthenticationProvider provider = null;

            // Dictionary keys are case sensitive.
            var key = providerKey.ToLowerInvariant();

            if (_authenticationProviderFactory.AuthenticationProviders.ContainsKey(key))
            {
                _traceSource.TraceVerbose("Found registered provider: " + key);
                provider = _authenticationProviderFactory.AuthenticationProviders[key];
            }
            else if (providerKey.StartsWith("fake", StringComparison.InvariantCultureIgnoreCase))
            {
                // Ah-ha! We've been asked for a fake key :P
                _traceSource.TraceVerbose("Request for a *Fake* provider. Creating the fake provider: " + providerKey);
                provider = new FakeProvider(providerKey);
            }

            // So, did we get a real or fake key?
            if (provider == null)
            {
                var errorMessage = string.Format("There was no provider registered for the given key: {0}.", providerKey);
                _traceSource.TraceError(errorMessage);
                throw new InvalidOperationException(errorMessage);
            }

            _traceSource.TraceVerbose("Found - Provider: {0}.",
                string.IsNullOrEmpty(provider.Name)
                    ? "-no provider name-"
                    : provider.Name);

            return provider;
        }

        private static Uri GenerateCallbackUri(Uri requestUri,
            string callbackRoute,
            string query = null)
        {
            // Optional, but UriBuilder doesn't like a null query value.
            if (query == null)
            {
                query = string.Empty;
            }

            var builder = new UriBuilder(requestUri)
            {
                Path = callbackRoute,
                Query = query
            };

            // Don't include port 80/443 in the Uri.
            if (builder.Uri.IsDefaultPort)
            {
                builder.Port = -1;
            }

            return builder.Uri;
        }

        private static string DetermineReturnUrl(string returnUrl,
            string referer)
        {
            // LOGIC: The idea here is that if we have a return url, then we will go there.
            //        Otherwise, we'll try falling back to the referer, if that was provided.
            //        Finally - nothing was provided, then nowhere to go.
            return !string.IsNullOrEmpty(returnUrl)
                ? returnUrl
                : !string.IsNullOrWhiteSpace(referer)
                    ? referer
                    : null;
        }

        private async Task<AuthenticateCallbackResult> RetrieveUserInformationAsync(AuthenticateCallbackAsyncData data)
        {
            if (data == null)
            {
                throw new ArgumentNullException("data");
            }

            // Which provider did we just authenticate with?
            var provider = GetAuthenticationProvider(data.CacheData.ProviderKey);

            // CRAZY?? Yeah, we still need the callback uri (even though we're -IN- the callback
            // because some providers use that as some security check or something. Urgh...
            var callbackUri = GenerateCallbackUri(data.RequestUrl, _callbackRoute);

            // Grab the user information.
            var model = new AuthenticateCallbackResult
            {
                AuthenticatedClient = await provider.AuthenticateClientAsync(data.QueryStringKeyValues,
                    data.CacheData.State,
                    callbackUri)
            };

            return model;
        }

        private TResult GetCachedMethodInfo<TInvokeObject, TModuleOrController, TResult>(
            TInvokeObject objectToInvokeOn,
            TModuleOrController moduleOrController,
            AuthenticateCallbackResult model)
        {
            // What callback type do we have?
            var type = typeof (TInvokeObject);

            // Is this cached?
            MethodInfo methodInfo;
            if (!_cachedMethodInfo.Value.TryGetValue(type.ToString(), out methodInfo))
            {
                // Can't find the item, so lets figure it out.
                methodInfo = type.GetMethod("Process");
               _cachedMethodInfo.Value.Add(type.ToString(), methodInfo);
            }

            return (TResult)methodInfo.Invoke(objectToInvokeOn,
                    new object[] { moduleOrController, model });

        }
    }
}